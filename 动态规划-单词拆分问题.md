[TOC]



## 暴力方法-后缀枚举

```python
def wordBreak(s: str, wordDict: list[str]) -> bool:
    word_set = set(wordDict)
    n = len(s)
    
    def backtrack(end):
        if end == 0:
            return True
        # 枚举所有后缀拆分点
        for j in range(end):
            suffix = s[j:end]
            if suffix in word_set and backtrack(j):
                return True
        return False
    
    return backtrack(n)


def wordBreak(s: str, wordDict: list[str]) -> bool:
    def dfs(remaining: str) -> bool:
        if not remaining:
            return True
        for i in range(1, len(remaining) + 1):
            # 直接用列表查询（O(m) 时间，m 是字典长度），无任何优化
            if remaining[:i] in wordDict:
                if dfs(remaining[i:]):
                    return True
        return False
    return dfs(s)
```

## 暴力方法-前缀

```python
def wordBreak(s: str, wordDict: list[str]) -> bool:
    word_set = set(wordDict)
    n = len(s)
    
    def backtrack(start):
        if start == n:
            return True
        # 枚举所有前缀拆分点
        for i in range(start + 1, n + 1):
            prefix = s[start:i]
            if prefix in word_set and backtrack(i):
                return True
        return False
    
    return backtrack(0)
```



## 递归版动态规划方法

```python
# 暴力方法改成“前缀子问题”（递归版DP雏形）
def wordBreak(s: str, wordDict: list[str]) -> bool:
    word_set = set(wordDict)
    n = len(s)
    # memo[i] 缓存 s[0..i-1] 能否拆分的结果
    memo = [-1] * (n + 1)
    
    def dfs(i):
        if i == 0:
            return True
        if memo[i] != -1:
            return memo[i]
        # 找 j < i，判断 s[j:i] 合法 + s[0..j-1] 能拆
        for j in range(i):
            if dfs(j) and s[j:i] in word_set:
                memo[i] = True
                return True
        memo[i] = False
        return False
    
    return dfs(n)
```

## 标准动态规划方法

```

```

