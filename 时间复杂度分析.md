[TOC]

## 快排的时间复杂度

快速排序（Quick Sort）是一种基于“分治法”的高效排序算法，其时间复杂度并非固定值，而是受** pivot（基准元素）选择策略** 和 **输入数据分布** 影响，存在最好、平均、最坏三种情况。以下从算法核心逻辑出发，详细分析三种时间复杂度，并补充优化思路。


#### 一、先明确：快排的核心逻辑
快排的时间消耗主要集中在“分治”过程中的**元素比较**和**数组划分**，核心步骤可概括为：
1. **选择基准（pivot）**：从数组中挑选一个元素作为“基准”，用于划分数组。
2. **划分（Partition）**：将数组中小于 pivot 的元素移到左侧，大于 pivot 的元素移到右侧，pivot 最终落在“正确位置”（即排序后它应处的位置）。
3. **递归排序**：对 pivot 左侧的子数组和右侧的子数组，重复上述步骤，直到子数组长度为 1（无需排序）或 0（空数组）。


#### 二、三种时间复杂度分析
快排的时间复杂度本质是“递归树的深度 × 每一层的比较次数”，不同 pivot 选择会导致递归树结构差异，进而影响复杂度。


##### 1. 最坏情况时间复杂度：O(n²)
###### 触发条件
当 pivot 选择“极差”时，每次划分都将数组分成**极不均衡的两部分**（例如：一侧子数组长度为 0，另一侧为 n-1）。  
典型场景：

- 输入数组已**完全有序**（升序/降序），且每次选择“最左元素”或“最右元素”作为 pivot。
- 输入数组所有元素**完全相同**，且 pivot 选择固定位置（如最左）。

###### 推导过程
以“有序数组+选最左为 pivot”为例：
- 第 1 层递归：数组长度为 n，划分后左侧子数组长度 0，右侧为 n-1，需比较 n-1 次（每个元素与 pivot 比较）。
- 第 2 层递归：仅处理右侧子数组（长度 n-1），划分后右侧子数组长度 n-2，需比较 n-2 次。
- ...
- 第 n-1 层递归：处理长度为 2 的子数组，划分后右侧子数组长度 1，需比较 1 次。

总比较次数 = (n-1) + (n-2) + ... + 1 = **n(n-1)/2**，即时间复杂度为 O(n²)（忽略低阶项和常数）。


##### 2. 最好情况时间复杂度：O(n log n)
###### 触发条件
当 pivot 选择“最优”时，每次划分都将数组分成**几乎均衡的两部分**（两侧子数组长度相差不超过 1）。  
典型场景：每次选择的 pivot 恰好是当前数组的“中位数”（或接近中位数）。

###### 推导过程
以“每次划分后子数组长度为 ⌊n/2⌋ 和 ⌈n/2⌉ - 1”为例：
- 递归树的深度：每次数组长度减半，直到子数组长度为 1，深度为 **log₂n**（例如 n=8 时，深度为 3：8→4→2→1）。
- 每一层的比较次数：无论如何划分，每一层所有子数组的总长度始终为 n（因为划分是“拆分原数组”，不新增元素），因此每一层需比较 n 次（忽略常数项）。

总比较次数 = n × log n，即时间复杂度为 O(n log n)。


##### 3. 平均情况时间复杂度：O(n log n)
实际应用中，很少遇到“完全有序”或“所有元素相同”的极端情况，多数场景下 pivot 选择会导致“随机划分”（即使是简单的“选中间元素”或“三数取中”），此时快排的平均时间复杂度为 O(n log n)。

###### 数学推导（简化版）
设 T(n) 为排序长度为 n 的数组的平均时间，核心递推关系如下：
1. **划分时间**：O(n)（遍历数组一次，完成划分）。
2. **递归时间**：假设 pivot 落在第 k 个位置（k 从 1 到 n 等概率），则左侧子数组长度为 k-1，右侧为 n-k，递归时间为 [T(0)+T(1)+...+T(n-1)]/n + [T(0)+T(1)+...+T(n-1)]/n（左右子数组的平均时间）。
3. **边界条件**：T(0)=T(1)=O(1)（空数组或长度为 1 的数组无需排序）。

通过递推公式化简（需用数学归纳法或求和公式），最终可证明 T(n) = O(n log n)。


#### 三、关键优化：如何避免 O(n²) 并贴近平均复杂度？
最坏情况的根源是“pivot 选择不当”，因此优化的核心是**让 pivot 尽可能接近数组中位数**，常见策略：
1. **三数取中（Median of Three）**：从数组的“最左、最右、中间”三个元素中选择中位数作为 pivot，避免有序数组的极端情况。
2. **随机选择（Random Pivot）**：随机挑选一个元素作为 pivot，从概率上消除“固定位置选择”的最坏情况（除非运气极差，否则几乎不会触发 O(n²)）。
3. **处理重复元素（三路快排）**：当数组存在大量重复元素时，传统快排会将重复元素集中在一侧，导致划分不均衡；三路快排将数组划分为“小于 pivot、等于 pivot、大于 pivot”三部分，仅递归排序“小于”和“大于”的部分，减少递归次数。


#### 四、复杂度对比总结
为了更清晰地理解快排的复杂度特性，下表对比三种情况：

| 复杂度类型 | 时间复杂度 | 触发条件 | 实际意义 |
|------------|------------|----------|----------|
| 最坏情况   | O(n²)      | pivot 选择极差（如有序数组选最左/最右） | 需通过优化 pivot 避免，实际极少遇到 |
| 最好情况   | O(n log n) | pivot 为数组中位数，划分完全均衡 | 理想场景，复杂度最优 |
| 平均情况   | O(n log n) | 随机划分或 pivot 接近中位数 | 实际应用中最常见的情况，快排高效性的核心 |

### 划分之后，比较的数据范围缩小了，为啥每层的比较还是n次？

这个问题的核心是理解「快排的比较操作本质是“遍历当前层所有待排序元素”」—— 划分后子数组的范围确实缩小了，但**同一递归层中所有子数组的总长度始终等于原始数组长度n**，因此每一层的总比较次数始终是O(n)（忽略常数项）。

我们用具体例子和可视化来拆解，你会更易理解：


#### 一、用“数组长度=8”的例子，直观看每一层的比较次数
假设原始数组是 `[5,3,8,6,2,7,1,4]`，无论怎么划分（哪怕不均衡），我们跟踪每一层的子数组总长度：

##### 第1层（最顶层，递归入口）
- 待排序数组：`[5,3,8,6,2,7,1,4]`（长度=8）
- 操作：选pivot（比如5），遍历整个数组，将元素与pivot比较，完成划分（比如分成 `[3,2,1,4]` 和 `[8,6,7]`）
- 比较次数：8次（每个元素都要和pivot比1次）
- 本层总子数组长度：4 + 3 = 7？不对！漏了pivot本身（5）—— 划分后pivot已经落在“最终位置”，不再参与后续递归，所以本层处理的“待排序元素”总长度是8，比较次数=8次（覆盖所有元素）。

##### 第2层（递归处理第1层的两个子数组）
- 待排序子数组1：`[3,2,1,4]`（长度=4）
  - 操作：选pivot（比如3），遍历4个元素比较，划分成 `[2,1]` 和 `[4]`
  - 比较次数：4次
- 待排序子数组2：`[8,6,7]`（长度=3）
  - 操作：选pivot（比如8），遍历3个元素比较，划分成 `[6,7]` 和 `[]`（空数组）
  - 比较次数：3次
- 本层总比较次数：4 + 3 = 7次（接近n=8，差的1次是第1层已经排好的pivot5，不再参与）

##### 第3层（递归处理第2层的子数组）
- 待排序子数组1：`[2,1]`（长度=2）→ 比较2次，划分成 `[1]` 和 `[]`
- 待排序子数组2：`[4]`（长度=1）→ 无需比较（子数组长度≤1，直接返回）
- 待排序子数组3：`[6,7]`（长度=2）→ 比较2次，划分成 `[6]` 和 `[7]`
- 本层总比较次数：2 + 0 + 2 = 4次（依然是“当前层待排序元素总长度”：2+1+2=5？不对，`[4]` 无需比较，实际比较的是2+2=4，还是覆盖了本层所有“需要处理的元素”）

##### 第4层（递归处理第3层的子数组）
- 待排序子数组：`[1]`、`[6]`、`[7]`（均为长度1）→ 无需任何比较
- 本层总比较次数：0次

#### 二、核心逻辑：比较次数 = 每一层“待排序元素的总长度”
快排的比较操作只发生在「划分阶段」—— 划分的本质是“给当前子数组的每个元素找位置（小于/大于pivot）”，因此**每个子数组的划分比较次数 = 该子数组的长度**（每个元素都要和pivot比1次）。

而关键在于：
- 递归的每一层，所有“待划分的子数组”都是「上一层数组拆分后的产物」，且拆分过程中**没有新增元素，也没有丢失元素**（只是把元素分到不同子数组，pivot排好后不再参与后续层）。
- 因此，每一层所有待划分子数组的总长度 ≤ n（因为每一层都会有至少1个pivot排好位置，不再参与下一层）。
- 从宏观上看，所有层的比较次数总和 = 第1层（n） + 第2层（n-1） + 第3层（n-3） + ... + 最后一层（0）≈ n log n（因为递归深度是log n层）。

#### 三、为什么“划分后范围缩小，总比较次数却不变”？
你觉得“范围缩小”是指「单个子数组的长度变小」，但忽略了「同一层有多个子数组」—— 单个子数组的范围确实缩小了，但多个子数组的范围加起来，覆盖了当前层所有“还没排好序的元素”，这些元素都需要通过比较来划分。

举个极端例子（最坏情况，每次划分成0和n-1）：
- 第1层：数组长度n → 比较n次，划分成0和n-1（pivot排好）
- 第2层：子数组长度n-1 → 比较n-1次，划分成0和n-2（又一个pivot排好）
- 第3层：子数组长度n-2 → 比较n-2次...
- 第n层：子数组长度1 → 比较0次

总比较次数 = n + (n-1) + (n-2) + ... + 1 = n(n-1)/2（O(n²)），这里每一层的比较次数就是“当前层待排序子数组的长度”，总和依然是所有层的“子数组长度和”。

#### 四、一句话总结
快排的每一层，本质是在“处理所有还没找到最终位置的元素”—— 这些元素分散在多个子数组中，但总数量始终≤n，因此每一层的总比较次数始终是O(n)；而递归深度决定了有多少层，所以总时间复杂度= 层数 × 每层比较次数 = log n × n = O(n log n)（平均/最好情况）。

