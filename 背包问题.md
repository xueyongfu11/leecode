[TOC]



## 背包问题

```python
def zero_one_knapsack(weights, values, capacity):
    """
    0-1背包问题动态规划解法
    :param weights: 物品重量列表（索引对应物品编号，从0开始）
    :param values: 物品价值列表（与重量列表一一对应）
    :param capacity: 背包最大承重
    :return: max_value（最大总价值）, selected_items（所选物品编号列表，从1开始）
    """
    n = len(weights)  # 物品数量
    # 1. 初始化DP表：dp[i][j]表示前i件物品、承重j时的最大价值
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]
    
    # 2. 填充DP表
    for i in range(1, n + 1):
        for j in range(1, capacity + 1):
            weight_i = weights[i - 1]  # 第i件物品的重量（列表索引从0开始）
            value_i = values[i - 1]    # 第i件物品的价值
            if j < weight_i:
                # 背包承重不够，不选第i件物品
                dp[i][j] = dp[i - 1][j]
            else:
                # 选或不选，取最大值
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight_i] + value_i)
    
    # 3. 回溯找出所选物品（从1开始编号）
    selected_items = []
    remaining_capacity = capacity  # 剩余承重
    for i in range(n, 0, -1):
        # 若dp[i][remaining_capacity] != dp[i-1][remaining_capacity]，说明选了第i件物品
        if dp[i][remaining_capacity] != dp[i - 1][remaining_capacity]:
            selected_items.append(i)  # 记录物品编号（1-based）
            remaining_capacity -= weights[i - 1]  # 减去该物品重量
    selected_items.reverse()  # 反转后按编号顺序排列
    
    return dp[n][capacity], selected_items


# ---------------------- 示例测试（对应之前的问题）----------------------
if __name__ == "__main__":
    # 物品信息（与问题描述一致：3件物品，重量[2,3,4]，价值[3,4,5]）
    weights = [2, 3, 4]    # 物品1-3的重量
    values = [3, 4, 5]     # 物品1-3的价值
    capacity = 5           # 背包最大承重5kg
    
    # 调用函数求解
    max_value, selected = zero_one_knapsack(weights, values, capacity)
    
    # 输出结果
    print("===== 0-1背包问题求解结果 =====")
    print(f"背包最大承重：{capacity}kg")
    print(f"物品列表：")
    for i in range(len(weights)):
        print(f"  物品{i+1}：重量{weights[i]}kg，价值{values[i]}元")
    print(f"\n最大总价值：{max_value}元")
    print(f"所选物品：{selected}（编号）")
    print(f"所选物品总重量：{sum(weights[i-1] for i in selected)}kg")
```

